/*
2022.3.22(화)

1. 포인터에 비해 Comptr의 장점은? → 마이크로소프트에서 Comptr를 장려 ? >> 디스코드에 올렸다는데.
2. Reset을 해줘야 하나? → 명시적으로 하는게 좋으니 Reset 해줘야 한다.모든 Comptr에 Reset 함수가 존재 한다는데? → 진짜 있네.
3. ??

저번에 Renderer 한 거 문제가 있었다.
변수들을 전역변수로 선언했었다는 거. 코드의 재사용성, 유용성이 좋지 않다. 하드코딩 되었다.
그리고 만들어야 할 변수들이 몇 개인데, 그거 다 전역으로 할거냐?
이번 실습은, 저번 실습을 객체 지향으로 만들 것이다.
WindowProc은 static이어야 해. 왜? 함수 포인터를 전달해주니까. DerivedType 템플릿으로 만들 거야. 이해안돼? 외워.

struct StateInfo{
};

LPARAM lParam을 형변환 어쩌구 해야지 StateInfo에서 받을 수 있다?
이태리체 - 순수가상함수
노란색 다이아몬드 - protected
초록색 다이아몬드 - public
밑줄 - static

이번엔 CleanupDevice가 없다. 왤까? 컴포인터라서 알아서 릴리즈가 된다.
*/

/*
2022.3.29(화)

객체 지향을 공부하는 방법은 여러 번 코드를 갈아 엎는 과정을 거치는 것이다.
m_의 의미가 멤버 변수구나;
출력 창을 매우 크게 해놓고 사용하네. 근데 뭐 이렇게 창이 많아?
콜스택이 함수 실행 순서를 보여주는구나.

본 수업?
삼각형 만들게. Vertex 하나 만들어서 Position만 넣을게.
삼각형 그릴거니까 점 3개 배열로 만듦.
D3D11_BUFFER_DESC bd = {};
채우고, subResourceData 하고...
InDexBuffer도 만들고,
등등
*/